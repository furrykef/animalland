Our hack uses an expanded ROM. This means, if you are hacking a copy of the original Japanese ROM, you should expand the ROM to 256 KB before trying to build the project. Adding 128 KB of anything to the end of the file should be sufficient.

The font is a 1bpp raw file named vwf.bin. It can be edited in tools such as Tile Layer Pro and Tile Molester. The width of each character is defined in the char_widths table in animalhack.asm.

The "no" symbol (a circle with a slash through it) appears in the font for characters that correspond to control codes; it's useless to put anything there except as an easter egg. (It's possible we didn't find all of 'em, so always check to see if your special character will display.) The character $10 in the charset ($90 in the game script) is also a control code for menus, though it's blank, because it also gets displayed (as a space).

The script is a standard Atlas script.

The game's text formatting routine will wrap lines automatically, and it will automatically prompt for a keypress if the text goes past the bottom margin. I wanted to make it smart enough not to ask for a keypress in the middle of a sentence, but in the end I decided it's not worth the effort. Instead I took note of passages where this happens and inserted prompts at appropriate places by hand.


Graphics
--------
Background images are stored in an RLE format. Each image has the following format:

The first two bytes give the size of the compressed image in bytes, including the size of this header. This tells the program how many bytes to skip to get to the next image. Therefore, when replacing an image, this value should NOT be updated even if the new image is smaller.

Next are four blocks of pattern data. The first block is loaded into VRAM location $0000, the second is loaded into $0800, the third is loaded into $2000, and the fourth is loaded into $2800. Each block starts with a one-byte header that indicates how many tiles to skip. For instance, if the first byte of the second block is 8, the data will be written to $0840, eight tiles after $0800.

The pattern data streams are compressed using an RLE scheme using the following binary codes:
  * 00000000: denotes end of the pattern data.
  * 0nnnnnnn: the next byte is to be output n times (an RLE run). For example, the hex values 03 5a output 5a 5a 5a.
  * 1nnnnnnn: the next n bytes are to be copied verbatim. For example, the hex values 83 7c 24 02 output 7c 24 02.

(Note: The RLE encoder used in the original game uses RLE to encode runs of two bytes, which is inefficient, so it is quite easy to make new graphics fit in the same space as the old by using RLE only for repetitions of three or more bytes.)

Finally, after the four blocks comes the tilemap, uncompressed. Maps for backgrounds are 19x14, so they'll be 266 bytes.


The ASM code
------------
The game ROM is loaded into $4000-BFFF. The original game used $4000-7FFF for the game's code and data and $8000-BFFF for the script. This $8000-BFFF region could get switched with every chapter. This means each chapter could have up to 16 KB of text. That's more than we needed, so we decided to make it 12 KB, and filled the remaining 4 KB with code and data, since there wasn't enough space for it in the $4000-7FFF region. Since 4 KB is smaller than a bank, we had to duplicate this 4 KB in every bank that could be loaded in that region. Thus, the code that goes in this region is in multibank.asm, because it's assembled once and then included in several different banks using incbin. The multibank.sym file generated in the process is used to allow animalhack.asm to have access to symbols defined in multibank.asm.

So animalhack.asm mainly applies hacks to the original ROM code, and multibank.asm includes code and data that doesn't fit into animalhack.asm. Patches frequently take the form of animalhack.asm modifying a few instructions and then branching to somewhere in multibank.asm, since multibank.asm is where all our usable free space is.

It's an ugly system, but it works.
