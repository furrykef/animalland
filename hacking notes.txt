The font is a 1bpp raw file named vwf.bin. It can be edited in tools such as Tile Layer Pro and Tile Molester. The width of each character is defined in the char_widths table in animalhack.asm.

The "no" symbol (a circle with a slash through it) appears in the font for characters that correspond to control codes; it's useless to put anything there except as an easter egg. (It's possible we didn't find all of 'em, so always check to see if your special character will display.) The character $10 in the charset ($90 in the game script) is also a control code for menus, though it's blank, because it also gets displayed (as a space).

The script is a standard Atlas script.

The game's text formatting routine is pretty smart. It can wrap lines automatically, and it will automatically prompt for a keypress if the text goes on too long. It's even smart enough not to prompt for a keypress in the middle of a sentence, except for a logical pausing point such as a comma. If your text goes on too long with no place where it can pause, the game will print an error message. You would almost have to be doing it on purpose or writing very badly indeed for this to happen.


Text formatting algorithm
-------------------------
The text formatting algorithm is more complicated than in most games. As in most games, it will stop and ask the user to press a key if the text won't fit in the box. What it won't do, though, is do this in the middle of a sentence, except at a logical stopping point such as a comma.

The code for this is a little difficult to follow, especially since the code has to deal with horizontal word wrapping as well, so we will explain it here.

The formatter copies an entire block of text into a buffer. The formatter's job is to insert codes for newlines and "press a key" at appropriate places during the copy. The buffer is large enough for any reasonably sized blocks of text.

As the formatter copies text, it checks if it overflows the right margin. If it does, it moves the word to the next line. It continues in this fashion until it reaches the end of an utterance -- that is, until we reach a point that is acceptable to wait for a key. Let's call this a "stopping point". But we don't want to wait for a keypress at the end of every utterance, only when the next utterance does not fit. So it continues until the text goes beyond the bottom margin. When this happens, a "wait for keypress" is inserted at the last stopping point and the copying resumes from that point.
